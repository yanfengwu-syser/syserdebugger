// dia2.idl - Debug Information Access (DIA) interface description
//-----------------------------------------------------------------
//
// Copyright 1999-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------
import "objidl.idl";
import "oaidl.idl";
import "propidl.idl";

import "cvconst.h";

enum NameSearchOptions
{
    nsNone = 0,

    nsfCaseSensitive = 0x1,         // apply a case sensitive match
    nsfCaseInsensitive = 0x2,       // apply a case insensitive match
    nsfFNameExt = 0x4,              // treat names as paths and apply a filename.ext match
    nsfRegularExpression = 0x8,     // regular expression
    nsfUndecoratedName = 0x10,      // applies only to symbols that have both undecorated and decorated names

    // predefined names for backward source compatibility

    nsCaseSensitive = nsfCaseSensitive,             // apply a case sensitive match
    nsCaseInsensitive = nsfCaseInsensitive,         // apply a case insensitive match
    nsFNameExt = nsfCaseInsensitive | nsfFNameExt,  // treat names as paths and apply a filename.ext match
    nsRegularExpression = nsfRegularExpression | nsfCaseSensitive,      // regular expression (using only '*' and '?')
    nsCaseInRegularExpression = nsfRegularExpression | nsfCaseInsensitive,  // case insensitive regular expression
};


// the following are error HRESULTS returned by an IDiaDataSource they
// are based on the FACILITY_VISUALCPP (0x6d) defined in delayimp.h

enum 
{
    E_PDB_OK=((HRESULT) (((unsigned long)(1)<<31) | ((unsigned long)(((LONG)0x6d))<<16) | ((unsigned long)(1))) ),
    E_PDB_USAGE                 ,
    E_PDB_OUT_OF_MEMORY         , // not used, use E_OUTOFMEMORY
    E_PDB_FILE_SYSTEM           ,
    E_PDB_NOT_FOUND             ,
    E_PDB_INVALID_SIG           ,
    E_PDB_INVALID_AGE           ,
    E_PDB_PRECOMP_REQUIRED      ,
    E_PDB_OUT_OF_TI             ,
    E_PDB_NOT_IMPLEMENTED       ,   // use E_NOTIMPL
    E_PDB_V1_PDB                ,
    E_PDB_FORMAT                ,
    E_PDB_LIMIT                 ,
    E_PDB_CORRUPT               ,
    E_PDB_TI16                  ,
    E_PDB_ACCESS_DENIED         ,  // use E_ACCESSDENIED
    E_PDB_ILLEGAL_TYPE_EDIT     ,
    E_PDB_INVALID_EXECUTABLE    ,
    E_PDB_DBG_NOT_FOUND         ,
    E_PDB_NO_DEBUG_INFO         ,
    E_PDB_INVALID_EXE_TIMESTAMP ,
    E_PDB_RESERVED              ,
    E_PDB_DEBUG_INFO_NOT_IN_PDB ,
    E_PDB_MAX
};

//
// Errors in finding dynamically loaded dlls or functions.
//
enum
{
    DIA_E_MODNOTFOUND = E_PDB_MAX+1,
    DIA_E_PROCNOTFOUND,
};

#define PROPERTY_RW(type, name, prid, help)           \
        [propget, helpstring(help), id(prid)]         \
        HRESULT name([out, retval] type * pRetVal);   \
                                                      \
        [propput, helpstring(help), id(prid)]         \
        HRESULT name([in] type NewVal)

#define PROPERTY_ARRAY_RW(type, itype, name, prid, help)           \
        [propget, helpstring(help), id(prid)]         \
        HRESULT name([in] itype index, [out, retval] type * pRetVal);   \
                                                      \
        [propput, helpstring(help), id(prid)]         \
        HRESULT name([in] itype index, [in] type NewVal)

#define PROPERTY_RO(type, name, prid, help)           \
        [propget, helpstring(help), id(prid)]         \
        HRESULT name([out, retval] type * pRetVal) 

// type of callback arg to IDiaDataSource::loadDataForExe
typedef void (__cdecl *PfnPDBDebugDirV)(BOOL, /*const struct _IMAGE_DEBUG_DIRECTORY * */ void*);


interface IDiaSession;
interface IDiaEnumTables;

interface IDiaSymbol;
interface IDiaSourceFile;
interface IDiaLineNumber;
interface IDiaInjectedSource;
interface IDiaSegment;
interface IDiaSectionContrib;
interface IDiaFrameData;

[
    object,
    uuid(C32ADB82-73F4-421b-95D5-A4706EDF5DBE),
    local,
    helpstring("IDiaLoadCallback interface."),
    pointer_default(unique)
]
interface IDiaLoadCallback: IUnknown
{
    HRESULT NotifyDebugDir(
                [in] BOOL fExecutable, 
                [in] DWORD cbData,
                [in, size_is(cbData)] BYTE data[]); // really a const struct _IMAGE_DEBUG_DIRECTORY *

    HRESULT NotifyOpenDBG(
                [in] LPCOLESTR dbgPath, 
                [in] HRESULT resultCode);

    HRESULT NotifyOpenPDB(
                [in] LPCOLESTR pdbPath, 
                [in] HRESULT resultCode);

    HRESULT RestrictRegistryAccess();         // return hr != S_OK to prevent querying the registry for symbol search paths
    HRESULT RestrictSymbolServerAccess();     // return hr != S_OK to prevent accessing a symbol server
}

[
    object,
    uuid(4688a074-5a4d-4486-aea8-7b90711d9f7c),
    local,
    helpstring("IDiaLoadCallback interface."),
    pointer_default(unique)
]
interface IDiaLoadCallback2: IDiaLoadCallback
{
    HRESULT RestrictOriginalPathAccess();     // return hr != S_OK to prevent looking up PDB specified in the debug directory
    HRESULT RestrictReferencePathAccess();    // return hr != S_OK to prevent looking up for PDB where the EXE is located.
    HRESULT RestrictDBGAccess();              // return hr != S_OK to prevent looking up debug information from DBG files.
}

[
    object,
    uuid(587A461C-B80B-4f54-9194-5032589A6319),
    local,
    helpstring("IDiaReadExeAtOffsetCallback interface."),
    pointer_default(unique)
]
interface IDiaReadExeAtOffsetCallback: IUnknown
{    
    HRESULT ReadExecutableAt(
                [in] DWORDLONG fileOffset, 
                [in] DWORD cbData,
                [out] DWORD *pcbData,
                [out, size_is(cbData),
                length_is(*pcbData)] BYTE data[]);

}

[
    object,
    uuid(8E3F80CA-7517-432a-BA07-285134AAEA8E),
    local,
    helpstring("IDiaReadExeAtRVACallback interface."),
    pointer_default(unique)
]
interface IDiaReadExeAtRVACallback: IUnknown
{    
    HRESULT ReadExecutableAtRVA(
                [in] DWORD relativeVirtualAddress, 
                [in] DWORD cbData,
                [out] DWORD *pcbData,
                [out, size_is(cbData),
                length_is(*pcbData)] BYTE data[]);
}

[
    object,
    uuid(79F1BB5F-B66E-48e5-B6A9-1545C323CA3D),
    local,
    helpstring("IDiaDataSource Interface"),
    pointer_default(unique)
]
interface IDiaDataSource: IUnknown
{
    PROPERTY_RO( BSTR, lastError, 1, "Text for last load error." );

    //
    // loadDataFromPdb
    //
   HRESULT loadDataFromPdb(
               [in] LPCOLESTR pdbPath );

    //
    // loadAndValidateDataFromPdb
    //
   HRESULT loadAndValidateDataFromPdb(
               [in] LPCOLESTR pdbPath,
               [in] GUID* pcsig70,
               [in] DWORD sig,
               [in] DWORD age );

    //
    // loadDataForExe
    //
    HRESULT loadDataForExe(
               [in] LPCOLESTR executable,
               [in] LPCOLESTR searchPath,
               [in] IUnknown* pCallback );

    //
    // loadDataFromIStream
    //
    HRESULT loadDataFromIStream(
                [in] IStream *pIStream );


    HRESULT openSession( 
                [out] IDiaSession** ppSession 
                );
}

[
    object,
    uuid(CAB72C48-443B-48f5-9B0B-42F0820AB29A),
    local,
    helpstring("IDiaEnumSymbols Interface"),
    pointer_default(unique)
]
interface IDiaEnumSymbols: IUnknown
{
    PROPERTY_RO( IUnknown*, _NewEnum, DISPID_NEWENUM, "IEnumVARIANT version of IDiaEnumSymbols." );
    PROPERTY_RO( LONG, Count, 1, "Number of symbols." );

    [id(0), helpstring("Return the symbol for the given index.")]
    HRESULT Item([in] DWORD index, [out, retval]IDiaSymbol **symbol);

    HRESULT Next(
        [in] ULONG celt,          
        [out] IDiaSymbol ** rgelt,   
        [out] ULONG * pceltFetched 
    );
    HRESULT Skip(
        [in] ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        [out] IDiaEnumSymbols **ppenum);
}

[
    object,
    uuid(624B7D9C-24EA-4421-9D06-3B577471C1FA),
    local,
    helpstring("IDiaEnumSymbolsByAddr Interface"),
    pointer_default(unique)
]
interface IDiaEnumSymbolsByAddr: IUnknown
{
    //
    // Item(ByXxx) re-positions the enumerator to the item found
    //
    [helpstring("Return the symbol for the given address.")]
    HRESULT symbolByAddr(
        [in] DWORD isect, 
        [in] DWORD offset, 
        [out, retval]IDiaSymbol** ppSymbol);

    [helpstring("Return the symbol for the given relative virtual address.")]
    HRESULT symbolByRVA(
        [in] DWORD relativeVirtualAddress, 
        [out, retval]IDiaSymbol** ppSymbol);

    [helpstring("Return the symbol for the given virtual address.")]
    HRESULT symbolByVA(
        [in] ULONGLONG virtualAddress, 
        [out, retval]IDiaSymbol** ppSymbol);

    HRESULT Next(
        [in] ULONG celt,          
        [out] IDiaSymbol ** rgelt,   
        [out] ULONG * pceltFetched 
    );

    HRESULT Prev(
        [in] ULONG celt,          
        [out] IDiaSymbol ** rgelt,   
        [out] ULONG * pceltFetched 
    );

    HRESULT Clone(
        [out] IDiaEnumSymbolsByAddr **ppenum);
}

[
    object,
    uuid(10F3DBD9-664F-4469-B808-9471C7A50538),
    local,
    helpstring("IDiaEnumSourceFiles Interface"),
    pointer_default(unique)
]
interface IDiaEnumSourceFiles: IUnknown
{
    PROPERTY_RO( IUnknown*, _NewEnum, DISPID_NEWENUM, "IEnumVARIANT version of IDiaEnumSourceFiles." );
    PROPERTY_RO( LONG, Count, 1, "Number of source files." );

    [id(0), helpstring("Return the source file for the given index.")]
    HRESULT Item([in] DWORD index, [out, retval]IDiaSourceFile **sourceFile);

    HRESULT Next(
        [in] ULONG celt,          
        [out] IDiaSourceFile ** rgelt,   
        [out] ULONG * pceltFetched 
    );
    HRESULT Skip(
        [in] ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        [out] IDiaEnumSourceFiles **ppenum);
}

[
    object,
    uuid(FE30E878-54AC-44f1-81BA-39DE940F6052),
    local,
    helpstring("IDiaEnumLineNumbers Interface"),
    pointer_default(unique)
]
interface IDiaEnumLineNumbers: IUnknown
{
    PROPERTY_RO( IUnknown*, _NewEnum, DISPID_NEWENUM, "IEnumVARIANT version of IDiaEnumLineNumbers." );
    PROPERTY_RO( LONG, Count, 1, "Number of line numbers." );

    [id(0), helpstring("Return the line number for the given index.")]
    HRESULT Item([in] DWORD index, [out, retval]IDiaLineNumber **lineNumber);

    HRESULT Next(
        [in] ULONG celt,          
        [out] IDiaLineNumber ** rgelt,   
        [out] ULONG * pceltFetched 
    );
    HRESULT Skip(
        [in] ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        [out] IDiaEnumLineNumbers **ppenum);
}

[
    object,
    uuid(D5612573-6925-4468-8883-98CDEC8C384A),
    local,
    helpstring("IDiaEnumInjectedSources Interface"),
    pointer_default(unique)
]
interface IDiaEnumInjectedSources: IUnknown
{
    PROPERTY_RO( IUnknown*, _NewEnum, DISPID_NEWENUM, "IEnumVARIANT version of IDiaEnumInjectedSources." );
    PROPERTY_RO( LONG, Count, 1, "Number of injected source files." );

    [id(0), helpstring("Return the injected source for the given index.")]
    HRESULT Item([in] DWORD index, [out, retval]IDiaInjectedSource **injectedSource);

    HRESULT Next(
        [in] ULONG celt,          
        [out] IDiaInjectedSource ** rgelt,   
        [out] ULONG * pceltFetched 
    );
    HRESULT Skip(
        [in] ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        [out] IDiaEnumInjectedSources **ppenum);
}

[
    object,
    uuid(E8368CA9-01D1-419d-AC0C-E31235DBDA9F),
    local,
    helpstring("IDiaEnumSegments Interface"),
    pointer_default(unique)
]
interface IDiaEnumSegments: IUnknown
{
    PROPERTY_RO( IUnknown*, _NewEnum, DISPID_NEWENUM, "IEnumVARIANT version of IDiaEnumSegments." );
    PROPERTY_RO( LONG, Count, 1, "Number of segments." );

    [id(0), helpstring("Return the segment for the given index.")]
    HRESULT Item([in] DWORD index, [out, retval]IDiaSegment **segment);

    HRESULT Next(
        [in] ULONG celt,          
        [out] IDiaSegment ** rgelt,   
        [out] ULONG * pceltFetched 
    );
    HRESULT Skip(
        [in] ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        [out] IDiaEnumSegments **ppenum);
}

[
    object,
    uuid(1994DEB2-2C82-4b1d-A57F-AFF424D54A68),
    local,
    helpstring("IDiaEnumSectionContribs Interface"),
    pointer_default(unique)
]
interface IDiaEnumSectionContribs: IUnknown
{
    PROPERTY_RO( IUnknown*, _NewEnum, DISPID_NEWENUM, "IEnumVARIANT version of IDiaEnumSectionContribs." );
    PROPERTY_RO( LONG, Count, 1, "Number of section contributions." );

    [id(0), helpstring("Return the section contribution for the given index.")]
    HRESULT Item([in] DWORD index, [out, retval]IDiaSectionContrib **section);

    HRESULT Next(
        [in] ULONG celt,          
        [out] IDiaSectionContrib ** rgelt,   
        [out] ULONG * pceltFetched 
    );
    HRESULT Skip(
        [in] ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        [out] IDiaEnumSectionContribs **ppenum);
}

[
    object,
    uuid(9FC77A4B-3C1C-44ed-A798-6C1DEEA53E1F),
    local,
    helpstring("IDiaEnumFrameData Interface"),
    pointer_default(unique)
]
interface IDiaEnumFrameData: IUnknown
{
    PROPERTY_RO( IUnknown*, _NewEnum, DISPID_NEWENUM, "IEnumVARIANT version of IDiaEnumFrameData." );
    PROPERTY_RO( LONG, Count, 1, "Number of frames." );

    [id(0), helpstring("Return the frame for the given index.")]
    HRESULT Item([in] DWORD index, [out, retval]IDiaFrameData **frame);

    HRESULT Next(
        [in] ULONG celt,          
        [out] IDiaFrameData ** rgelt,   
        [out] ULONG * pceltFetched 
    );
    HRESULT Skip(
        [in] ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        [out] IDiaEnumFrameData **ppenum);

    //
    // The following two by-address lookups do not reposition the enumeration
    //
    [helpstring("Return the frame for the given relative virtual address.")]
    HRESULT frameByRVA(
        [in] DWORD relativeVirtualAddress, 
        [out, retval]IDiaFrameData **frame);

    [helpstring("Return the frame for the given virtual address.")]
    HRESULT frameByVA(
        [in] ULONGLONG virtualAddress, 
        [out, retval]IDiaFrameData **frame);
}

[
    object,
    uuid(486943E8-D187-4a6b-A3C4-291259FFF60D),
    local,
    helpstring("IDiaEnumDebugStreamData Interface"),
    pointer_default(unique)
]
interface IDiaEnumDebugStreamData: IUnknown
{
    PROPERTY_RO( IUnknown*, _NewEnum, DISPID_NEWENUM, "IEnumVARIANT version of IDiaEnumDebugStreamData." );
    PROPERTY_RO( LONG, Count, 1, "Number of elements in the stream." );
    PROPERTY_RO( BSTR, name, 2, "Stream name." );

    [id(0), helpstring("Return the element for the given index.")]
    HRESULT Item(
            [in] DWORD index, 
            [in] DWORD cbData,
            [out] DWORD *pcbData,
            [out, size_is(cbData),
            length_is(*pcbData)] BYTE data[]
            );

    HRESULT Next(
        [in] ULONG celt,          
        [in] DWORD cbData,
        [out] DWORD *pcbData,
        [out, size_is(cbData),
        length_is(*pcbData)] BYTE data[],
        [out] ULONG * pceltFetched 
    );
    HRESULT Skip(
        [in] ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        [out] IDiaEnumDebugStreamData **ppenum);
}

[
    object,
    uuid(08CBB41E-47A6-4f87-92F1-1C9C87CED044),
    local,
    helpstring("IDiaEnumDebugStreams Interface"),
    pointer_default(unique)
]
interface IDiaEnumDebugStreams: IUnknown
{
    PROPERTY_RO( IUnknown*, _NewEnum, DISPID_NEWENUM, "IEnumVARIANT version of IDiaEnumDebugStreams." );
    PROPERTY_RO( LONG, Count, 1, "Number of streams." );

    [id(0), helpstring("Return the stream for the given index.")]
    HRESULT Item([in] VARIANT index, [out, retval]IDiaEnumDebugStreamData **stream);

    HRESULT Next(
        [in] ULONG celt,          
        [out] IDiaEnumDebugStreamData ** rgelt,   
        [out] ULONG * pceltFetched 
    );
    HRESULT Skip(
        [in] ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        [out] IDiaEnumDebugStreams **ppenum);
}

struct DiaAddressMapEntry
{
    DWORD rva;
    DWORD rvaTo;
};

[
    object,
    uuid(B62A2E7A-067A-4ea3-B598-04C09717502C),
    local,
    helpstring("IDiaAddressMap Interface"),
    pointer_default(unique)
]
interface IDiaAddressMap: IUnknown
{
    PROPERTY_RW( BOOL, addressMapEnabled, 3, "Enable address translations." );
    PROPERTY_RW( BOOL, relativeVirtualAddressEnabled, 4, "Enable relative virtual address computations.");
    PROPERTY_RW( DWORD, imageAlign, 5, "Original image alignment." );

    HRESULT set_imageHeaders(
     [in] DWORD cbData,
     [in, size_is(cbData)] BYTE data[],      // actual type is IMAGE_SECTION_HEADER[]
     [in] BOOL originalHeaders );            // true: headers are original, that is, they match the debug symbols
                                             // false: headers are current, that is, they match the image

    HRESULT set_addressMap(
     [in] DWORD cData,          // number of entries in rva map
     [in, size_is(cData)] struct DiaAddressMapEntry data[],      // rva map
     [in] BOOL imageToSymbols );             // true:  map from image to symbols (omapt)
                                             // false: map from symbols to image (omapf)
};

[
    object,
    uuid(67138B34-79CD-4b42-B74A-A18ADBB799DF),
    local,
    helpstring("IDiaSession Interface"),
    pointer_default(unique)
]
interface IDiaSession: IUnknown
{
    PROPERTY_RW( ULONGLONG, loadAddress, 1, "Dll/Exe load address." );
    PROPERTY_RO( IDiaSymbol*, globalScope, 2, "Global scope (exe) symbol." );

    HRESULT getEnumTables( 
        [out] IDiaEnumTables** ppEnumTables );
    HRESULT getSymbolsByAddr( 
        [out] IDiaEnumSymbolsByAddr** ppEnumbyAddr );

    //
    // Queries that return sets of symbols
    //
    HRESULT findChildren( 
        [in] IDiaSymbol* parent, 
        [in] enum SymTagEnum symtag, 
        [in] LPCOLESTR name,
        [in] DWORD compareFlags,
        [out] IDiaEnumSymbols** ppResult );
    HRESULT findSymbolByAddr (
        [in] DWORD isect,
        [in] DWORD offset,
        [in] enum SymTagEnum symtag, 
        [out] IDiaSymbol** ppSymbol );
    HRESULT findSymbolByRVA (
        [in] DWORD rva,
        [in] enum SymTagEnum symtag, 
        [out] IDiaSymbol** ppSymbol );
    HRESULT findSymbolByVA (
        [in] ULONGLONG va,
        [in] enum SymTagEnum symtag, 
        [out] IDiaSymbol** ppSymbol );
    HRESULT findSymbolByToken (
        [in] ULONG token,
        [in] enum SymTagEnum symtag, 
        [out] IDiaSymbol** ppSymbol );
    HRESULT symsAreEquiv(
        [in] IDiaSymbol* symbolA, 
        [in] IDiaSymbol* symbolB );
    HRESULT symbolById(
        [in] DWORD id,
        [out] IDiaSymbol** ppSymbol );
    HRESULT findSymbolByRVAEx (
        [in] DWORD rva,
        [in] enum SymTagEnum symtag, 
        [out] IDiaSymbol** ppSymbol,
        [out] long* displacement );
    HRESULT findSymbolByVAEx (
        [in] ULONGLONG va,
        [in] enum SymTagEnum symtag, 
        [out] IDiaSymbol** ppSymbol,
        [out] long* displacement );

    //
    // Queries that return source file results
    //
    HRESULT findFile(
        [in] IDiaSymbol* pCompiland, 
        [in] LPCOLESTR name,
        [in] DWORD compareFlags,
        [out] IDiaEnumSourceFiles** ppResult );
    HRESULT findFileById(
        [in] DWORD uniqueId,
        [out] IDiaSourceFile** ppResult );

    //
    // Queries that return line number results
    //
    HRESULT findLines( 
        [in] IDiaSymbol* compiland, 
        [in] IDiaSourceFile* file, 
        [out] IDiaEnumLineNumbers** ppResult );
    HRESULT findLinesByAddr(
        [in] DWORD seg,
        [in] DWORD offset,
        [in] DWORD length,
        [out] IDiaEnumLineNumbers** ppResult );
    HRESULT findLinesByRVA(
        [in] DWORD rva,
        [in] DWORD length,
        [out] IDiaEnumLineNumbers** ppResult );
    HRESULT findLinesByVA(
        [in] ULONGLONG va,
        [in] DWORD length,
        [out] IDiaEnumLineNumbers** ppResult );
    HRESULT findLinesByLinenum(
        [in] IDiaSymbol* compiland, 
        [in] IDiaSourceFile* file,
        [in] DWORD linenum,
        [in] DWORD column,
        [out] IDiaEnumLineNumbers** ppResult );

    //
    // Queries that return injected source
    //
    HRESULT findInjectedSource( 
        [in] LPCOLESTR srcFile, 
        [out] IDiaEnumInjectedSources** ppResult );

    HRESULT getEnumDebugStreams( 
        [out] IDiaEnumDebugStreams** ppEnumDebugStreams );
};

/*
 *  Table Columns
 *
 *  Symbols - a symbol will have values in some subset of the fields
 */
[
    object,
    uuid(72827A48-D320-4eaf-8436-548ADE47D5E5),
    local,
    helpstring("IDiaSymbol Interface"),
    pointer_default(unique)
]
interface IDiaSymbol: IUnknown
{
    PROPERTY_RO( DWORD, symIndexId, 0, "Unique symbol identifier." );
    PROPERTY_RO( DWORD, symTag, 1, "Symbol kind tag." );
    PROPERTY_RO( BSTR, name, 2, "Name" );                     
    PROPERTY_RO( IDiaSymbol*, lexicalParent, 3, "Lexical parent symbol.");                  
    PROPERTY_RO( IDiaSymbol*, classParent, 4, ".");
    PROPERTY_RO( IDiaSymbol*, type, 5, ".");
    PROPERTY_RO( DWORD, dataKind, 6, ".");
    PROPERTY_RO( DWORD, locationType, 7, ".");
    PROPERTY_RO( DWORD, addressSection, 8, ".");
    PROPERTY_RO( DWORD, addressOffset, 9, ".");
    PROPERTY_RO( DWORD, relativeVirtualAddress, 10, ".");
    PROPERTY_RO( ULONGLONG, virtualAddress, 11, ".");
    PROPERTY_RO( DWORD, registerId, 12, ".");
    PROPERTY_RO( LONG, offset, 13, ".");
    PROPERTY_RO( ULONGLONG, length, 14, ".");
    PROPERTY_RO( DWORD, slot, 15, ".");
    PROPERTY_RO( BOOL, volatileType, 16, ".");
    PROPERTY_RO( BOOL, constType, 17, ".");
    PROPERTY_RO( BOOL, unalignedType, 18, ".");
    PROPERTY_RO( DWORD, access, 19, ".");
    PROPERTY_RO( BSTR, libraryName, 20, ".");
    PROPERTY_RO( DWORD, platform, 21, ".");
    PROPERTY_RO( DWORD, language, 22, ".");
    PROPERTY_RO( BOOL, editAndContinueEnabled, 23, ".");
    PROPERTY_RO( DWORD, frontEndMajor, 24, ".");
    PROPERTY_RO( DWORD, frontEndMinor, 25, ".");
    PROPERTY_RO( DWORD, frontEndBuild, 26, ".");
    PROPERTY_RO( DWORD, backEndMajor, 27, ".");
    PROPERTY_RO( DWORD, backEndMinor, 28, ".");
    PROPERTY_RO( DWORD, backEndBuild, 29, ".");
    PROPERTY_RO( BSTR, sourceFileName, 30, ".");
    PROPERTY_RO( BSTR, unused, 31, ".");
    PROPERTY_RO( DWORD, thunkOrdinal, 32, ".");
    PROPERTY_RO( LONG, thisAdjust, 33, ".");
    PROPERTY_RO( DWORD, virtualBaseOffset, 34, ".");
    PROPERTY_RO( BOOL, virtual, 35, ".");
    PROPERTY_RO( BOOL, intro, 36, ".");
    PROPERTY_RO( BOOL, pure, 37, ".");
    PROPERTY_RO( DWORD, callingConvention, 38, ".");
    PROPERTY_RO( VARIANT, value, 39, ".");
    PROPERTY_RO( DWORD, baseType, 40, ".");
    PROPERTY_RO( DWORD, token, 41, ".");
    PROPERTY_RO( DWORD, timeStamp, 42, ".");
    PROPERTY_RO( GUID, guid, 43, ".");
    PROPERTY_RO( BSTR, symbolsFileName, 44, ".");
    PROPERTY_RO( BOOL, reference, 46, ".");
    PROPERTY_RO( DWORD, count, 47, ".");
    PROPERTY_RO( DWORD, bitPosition, 49, ".");
    PROPERTY_RO( IDiaSymbol*, arrayIndexType, 50, ".");
    PROPERTY_RO( BOOL, packed, 51, ".");
    PROPERTY_RO( BOOL, constructor, 52, ".");
    PROPERTY_RO( BOOL, overloadedOperator, 53, ".");
    PROPERTY_RO( BOOL, nested, 54, ".");
    PROPERTY_RO( BOOL, hasNestedTypes, 55, ".");
    PROPERTY_RO( BOOL, hasAssignmentOperator, 56, ".");
    PROPERTY_RO( BOOL, hasCastOperator, 57, ".");
    PROPERTY_RO( BOOL, scoped, 58, ".");
    PROPERTY_RO( BOOL, virtualBaseClass, 59, ".");
    PROPERTY_RO( BOOL, indirectVirtualBaseClass, 60, ".");
    PROPERTY_RO( LONG, virtualBasePointerOffset, 61, ".");
    PROPERTY_RO( IDiaSymbol*, virtualTableShape, 62, ".");
    PROPERTY_RO( DWORD, lexicalParentId, 64, "Lexical parent symbol.");                  
    PROPERTY_RO( DWORD, classParentId, 65, ".");
    PROPERTY_RO( DWORD, typeId, 66, ".");
    PROPERTY_RO( DWORD, arrayIndexTypeId, 67, ".");
    PROPERTY_RO( DWORD, virtualTableShapeId, 68, ".");
    PROPERTY_RO( BOOL, code, 69, "Symbol refers to a code address." );
    PROPERTY_RO( BOOL, function, 70, "Symbol refers to a function." );
    PROPERTY_RO( BOOL, managed, 71, "Symbol refers to managed code." );
    PROPERTY_RO( BOOL, msil, 72, "Symbol refers to MSIL code." );
    PROPERTY_RO( DWORD, virtualBaseDispIndex, 73, ".");
    PROPERTY_RO( BSTR, undecoratedName, 74, ".");
    PROPERTY_RO( DWORD, age, 75, "PDB file age." );
    PROPERTY_RO( DWORD, signature, 76, "Signature." ); 
    PROPERTY_RO( BOOL, compilerGenerated, 77, "Symbol is compiler generated." );
    PROPERTY_RO( BOOL, addressTaken, 78, "Symbol is address taken." );
    PROPERTY_RO( DWORD, rank, 79, "Rank of FORTRAN multi-dimension array." );
    PROPERTY_RO( IDiaSymbol*, lowerBound, 80, "Lower bound of a FORTRAN array dimension.");
    PROPERTY_RO( IDiaSymbol*, upperBound, 81, "Upper bound of a FORTRAN array dimension.");
    PROPERTY_RO( DWORD, lowerBoundId, 82, "Symbol Id of the lower bound of a FORTRAN array dimension.");
    PROPERTY_RO( DWORD, upperBoundId, 83, "Symbol Id of the upper bound of a FORTRAN array dimension.");

    HRESULT get_dataBytes(
         [in] DWORD cbData,
         [out] DWORD *pcbData,
         [out, size_is(cbData),
         length_is(*pcbData)] BYTE data[]
        );

    HRESULT findChildren( 
        [in] enum SymTagEnum symtag, 
        [in] LPCOLESTR name,
        [in] DWORD compareFlags,
        [out] IDiaEnumSymbols** ppResult );

    PROPERTY_RO( DWORD, targetSection, 84, "Thunk target address section.");
    PROPERTY_RO( DWORD, targetOffset, 85, "Thunk target address offset.");
    PROPERTY_RO( DWORD, targetRelativeVirtualAddress, 86, "Thunk target RVA.");
    PROPERTY_RO( ULONGLONG, targetVirtualAddress, 87, "Thunk target virtual address.");
    PROPERTY_RO( DWORD, machineType, 88, "Target machine type." );
    PROPERTY_RO( DWORD, oemId, 89, "Identifier of manufacturer.");
    PROPERTY_RO( DWORD, oemSymbolId, 90, "Manufacturer defined custom symbol identifier." );
    HRESULT get_types(
         [in] DWORD cTypes,
         [out] DWORD *pcTypes,
         [out, size_is(cTypes),
         length_is(*pcTypes)] IDiaSymbol* types[]
        );
    HRESULT get_typeIds(
         [in] DWORD cTypeIds,
         [out] DWORD *pcTypeIds,
         [out, size_is(cTypeIds),
         length_is(*pcTypeIds)] DWORD typeIds[]
        );
    PROPERTY_RO( IDiaSymbol*, objectPointerType, 91, "Type of method's object pointer." );
    PROPERTY_RO( DWORD, udtKind, 92, "Struct, union or class.");
    HRESULT get_undecoratedNameEx(
        [in] DWORD undecorateOptions,
        [out] BSTR* name
        );
};

//
//  SourceFiles
//
[
    object,
    uuid(A2EF5353-F5A8-4eb3-90D2-CB526ACB3CDD),
    local,
    helpstring("IDiaSourceFile Interface"),
    pointer_default(unique)
]
interface IDiaSourceFile: IUnknown
{
    PROPERTY_RO( DWORD, uniqueId, 2, "Unique id for the source file (in this data store)." );
    PROPERTY_RO( BSTR, fileName, 3, "." );
    PROPERTY_RO( DWORD, checksumType, 4, "." );
    PROPERTY_RO( IDiaEnumSymbols*, compilands, 5, "." );

    HRESULT get_checksum(
         [in] DWORD cbData,
         [out] DWORD *pcbData,
         [out, size_is(cbData),
         length_is(*pcbData)] BYTE data[]
        );

};

//
//  LineNumbers
//
[
    object,
    uuid(B388EB14-BE4D-421d-A8A1-6CF7AB057086),
    local,
    helpstring("IDiaLineNumber Interface"),
    pointer_default(unique)
]
interface IDiaLineNumber: IUnknown
{
    PROPERTY_RO( IDiaSymbol*, compiland, 1, "." );
    PROPERTY_RO( IDiaSourceFile*, sourceFile, 2, "." );
    PROPERTY_RO( DWORD, lineNumber, 3, "." );
    PROPERTY_RO( DWORD, lineNumberEnd, 4, "." );
    PROPERTY_RO( DWORD, columnNumber, 5, "." );
    PROPERTY_RO( DWORD, columnNumberEnd, 6, "." );
    PROPERTY_RO( DWORD, addressSection, 7, "." );
    PROPERTY_RO( DWORD, addressOffset, 8, "." );
    PROPERTY_RO( DWORD, relativeVirtualAddress, 9, "." );
    PROPERTY_RO( ULONGLONG, virtualAddress, 10, "." );
    PROPERTY_RO( DWORD, length, 11, "." );
    PROPERTY_RO( DWORD, sourceFileId, 12, "." );
    PROPERTY_RO( BOOL, statement, 13, "." );
    PROPERTY_RO( DWORD, compilandId, 14, "." );
};

//
// SectionContributions
//
[
    object,
    uuid(0CF4B60E-35B1-4c6c-BDD8-854B9C8E3857),
    local,
    helpstring("IDiaSectionContrib Interface"),
    pointer_default(unique)
]
interface IDiaSectionContrib: IUnknown
{
    PROPERTY_RO( IDiaSymbol*, compiland, 1, "." );
    PROPERTY_RO( DWORD, addressSection, 2, "." );
    PROPERTY_RO( DWORD, addressOffset, 3, "." );
    PROPERTY_RO( DWORD, relativeVirtualAddress, 4, "." );
    PROPERTY_RO( ULONGLONG, virtualAddress, 5, "." );
    PROPERTY_RO( DWORD, length, 6, "." );
    // 7
    PROPERTY_RO( BOOL, notPaged, 8, ".");
    PROPERTY_RO( BOOL, code, 9, ".");
    PROPERTY_RO( BOOL, initializedData, 10, ".");
    PROPERTY_RO( BOOL, uninitializedData, 11, ".");
    PROPERTY_RO( BOOL, remove, 12, ".");
    PROPERTY_RO( BOOL, comdat, 13, ".");
    PROPERTY_RO( BOOL, discardable, 14, ".");
    PROPERTY_RO( BOOL, notCached, 15, ".");
    PROPERTY_RO( BOOL, share, 16, ".");
    PROPERTY_RO( BOOL, execute, 17, ".");
    PROPERTY_RO( BOOL, read, 18, ".");
    PROPERTY_RO( BOOL, write, 19, ".");
    PROPERTY_RO( DWORD, dataCrc, 20, "." );
    PROPERTY_RO( DWORD, relocationsCrc, 21, "." );
    PROPERTY_RO( DWORD, compilandId, 22, "." );
};

//
// SegmentMap
//
[
    object,
    uuid(0775B784-C75B-4449-848B-B7BD3159545B),
    local,
    helpstring("IDiaSegment Interface"),
    pointer_default(unique)
]
interface IDiaSegment: IUnknown
{
    PROPERTY_RO( DWORD, frame, 1, "Frame." );
    PROPERTY_RO( DWORD, offset, 2, "Offset in physical section." );
    PROPERTY_RO( DWORD, length, 3, "Length in bytes of segment." );
    PROPERTY_RO( BOOL, read, 4, "Read allowed." );
    PROPERTY_RO( BOOL, write, 5, "Write allowed." );
    PROPERTY_RO( BOOL, execute, 6, "Execute allowed." );
    PROPERTY_RO( DWORD, addressSection, 7, "." );
    PROPERTY_RO( DWORD, relativeVirtualAddress, 8, "." );
    PROPERTY_RO( ULONGLONG, virtualAddress, 9, "." );
};

//
// InjectedSource
//
[
    object,
    uuid(AE605CDC-8105-4a23-B710-3259F1E26112),
    local,
    helpstring("IDiaInjectedSource Interface"),
    pointer_default(unique)
]
interface IDiaInjectedSource: IUnknown
{
    PROPERTY_RO( DWORD, crc, 1, "CRC of source bytes." );
    PROPERTY_RO( ULONGLONG, length, 2, "Length of source in bytes." );
    PROPERTY_RO( BSTR, filename, 3, "Source filename." );
    PROPERTY_RO( BSTR, objectFilename, 4, "Object filename." );
    PROPERTY_RO( BSTR, virtualFilename, 5, "Virtual filename." );
    PROPERTY_RO( DWORD, sourceCompression, 6, "Source compression algorithm." );
    HRESULT get_source(
         [in] DWORD cbData,
         [out] DWORD *pcbData,
         [out, size_is(cbData),
         length_is(*pcbData)] BYTE data[]
        );
};

//
// Errors returned by IDiaFrameData::execute
//
enum 
{
    E_DIA_INPROLOG          // cannot execute stack frame when in prolog
            =((HRESULT) (((unsigned long)(1)<<31) | ((unsigned long)(((LONG)0x6d))<<16) | ((unsigned long)(100))) ),
    E_DIA_SYNTAX,           // error parsing frame program
    E_DIA_FRAME_ACCESS,     // error accessing registers or memory
    E_DIA_VALUE,            // error in computer a value (e.g., divide by zero)
};


[
    object,
    uuid(97F0F1A6-E04E-4ea4-B4F9-B0D0E8D90F5D),
    local,
    helpstring("IDiaStackWalkFrame Interface"),
    pointer_default(unique)
]
interface IDiaStackWalkFrame: IUnknown
{
    PROPERTY_ARRAY_RW( ULONGLONG, DWORD, registerValue, 1, "Register value." ); 
    HRESULT readMemory( 
         [in] ULONGLONG va,
         [in] DWORD cbData,
         [out] DWORD *pcbData,
         [out, size_is(cbData),
         length_is(*pcbData)] BYTE data[]
         );
    HRESULT searchForReturnAddress(
        [in] IDiaFrameData* frame,
        [out] ULONGLONG* returnAddress
        );
    HRESULT searchForReturnAddressStart(
        [in] IDiaFrameData* frame,
        [in] ULONGLONG startAddress,
        [out] ULONGLONG* returnAddress
        );
};


[
    object,
    uuid(A39184B7-6A36-42de-8EEC-7DF9F3F59F33),
    local,
    helpstring("IDiaFrameData Interface"),
    pointer_default(unique)
]
interface IDiaFrameData: IUnknown
{
    PROPERTY_RO( DWORD, addressSection, 2, "." );
    PROPERTY_RO( DWORD, addressOffset, 3, "." );
    PROPERTY_RO( DWORD, relativeVirtualAddress, 4, "." );
    PROPERTY_RO( ULONGLONG, virtualAddress, 5, "." );
    PROPERTY_RO( DWORD, lengthBlock, 6, "." );
    PROPERTY_RO( DWORD, lengthLocals, 7, "." );
    PROPERTY_RO( DWORD, lengthParams, 8, "." );
    PROPERTY_RO( DWORD, maxStack, 9, "." );
    PROPERTY_RO( DWORD, lengthProlog, 10, "." );
    PROPERTY_RO( DWORD, lengthSavedRegisters, 11, "." );
    PROPERTY_RO( BSTR, program, 12, "." );
    PROPERTY_RO( BOOL, systemExceptionHandling, 13, "." );
    PROPERTY_RO( BOOL, cplusplusExceptionHandling, 14, "." );
    PROPERTY_RO( BOOL, functionStart, 15, "." );
    PROPERTY_RO( BOOL, allocatesBasePointer, 16, "." );
    PROPERTY_RO( DWORD, type, 17, "." );
    PROPERTY_RO( IDiaFrameData*, functionParent, 18, "Frame data for enclosing function.");                  

    HRESULT execute( IDiaStackWalkFrame* frame );
}

//
// IDiaImageData
//
//      Some debug streams (XDATA, PDATA) contain copies of data also stored in the image. The
//      stream data objects (IDiaEnumDebugStreamData) can be QI'ed for their IDiaImageData.
[
    object,
    uuid(C8E40ED2-A1D9-4221-8692-3CE661184B44),
    local,
    helpstring("IDiaImageData Interface"),
    pointer_default(unique)
]
interface IDiaImageData: IUnknown
{
    PROPERTY_RO( DWORD, relativeVirtualAddress, 2, "." );
    PROPERTY_RO( ULONGLONG, virtualAddress, 3, "." );
    PROPERTY_RO( ULONGLONG, imageBase, 4, "." );
}

//
// IDiaTable
//      Supports enumerating the members of the table
//
[
    object,
    uuid(4A59FB77-ABAC-469b-A30B-9ECC85BFEF14),
    local,
    helpstring("IDiaTable Interface"),
    pointer_default(unique)
]
interface IDiaTable: IEnumUnknown
{
    PROPERTY_RO( IUnknown*, _NewEnum, DISPID_NEWENUM, "IEnumVARIANT version of IDiaTable." );
    PROPERTY_RO( BSTR, name, 1, "Table name." );
    PROPERTY_RO( LONG, Count, 2, "Number of table entries." );

    [id(0), helpstring("Return the table element for the given index.")]
    HRESULT Item([in] DWORD index, [out, retval]IUnknown **element); // ### IDispatch?

};

[
    object,
    uuid(C65C2B0A-1150-4d7a-AFCC-E05BF3DEE81E),
    local,
    helpstring("IDiaEnumTables Interface"),
    pointer_default(unique)
]
interface IDiaEnumTables: IUnknown
{
    PROPERTY_RO( IUnknown*, _NewEnum, DISPID_NEWENUM, "IEnumVARIANT version of IDiaEnumTables." );
    PROPERTY_RO( LONG, Count, 1, "Number of tables." );

    [id(0), helpstring("Return the table for the given index or name.")]
    HRESULT Item([in] VARIANT index, [out, retval]IDiaTable **table);

    HRESULT Next(
        ULONG celt,          
        IDiaTable ** rgelt,   
        ULONG * pceltFetched 
    );
    HRESULT Skip(
        [in] ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        [out] IDiaEnumTables **ppenum);
};

[
    uuid(106173A0-0173-4e5c-84E7-E915422BE997),
    version(2.0),
    helpstring("dia 2.0 Type Library")
]
library Dia2Lib
{

    importlib("stdole2.tlb");
    [
        uuid(e60afbee-502d-46ae-858f-8272a09bd707),
        helpstring("DiaSource Class")
    ]
    coclass DiaSource
    {
        [default] interface IDiaDataSource;
    };

    //
    // DiaSourceAlt - a DiaDataSource object that does not use the system heap. 
    //
    // A process may either make DiaSourceAlt objects or DiaSource objects, but not both.
    // When using DiaSourceAlt all returned BSTR's are really LPCOLESTR and should not be 
    // used with other BSTR management routines, in particular they must be released using
    //      LocalFree( bstr )
    [
        uuid(9c1c335f-d27d-4857-bda0-2c7364544706),
        helpstring("Local Heap DiaSource Class")
    ]
    coclass DiaSourceAlt
    {
        [default] interface IDiaDataSource;
    };


    // General stack walking API    
    [
        uuid(31495af6-0897-4f1e-8dac-1447f10174a1),
        helpstring("General Stackwalk Class")
    ]
    coclass DiaStackWalker
    {
        [default] interface IDiaStackWalker;
    };
};

//
// DebugInfoTable
//
// Each id identifies an underlying table of debug information 
// 

const LPOLESTR DiaTable_Symbols = L"Symbols";
const LPOLESTR DiaTable_Sections = L"Sections";
const LPOLESTR DiaTable_SrcFiles = L"SourceFiles";
const LPOLESTR DiaTable_LineNums = L"LineNumbers";
const LPOLESTR DiaTable_SegMap = L"SegmentMap";
const LPOLESTR DiaTable_Dbg = L"Dbg";
const LPOLESTR DiaTable_InjSrc = L"InjectedSource";
const LPOLESTR DiaTable_FrameData = L"FrameData";


// Generic property broweser interface.
[
    object,
    uuid(9d416f9c-e184-45b2-a4f0-ce517f719e9b),
    local,
    helpstring("IDiaPropertyStorage Interface"),
    pointer_default(unique)
]
interface IDiaPropertyStorage: IUnknown
{

    HRESULT ReadMultiple(
        [in] ULONG cpspec,                  //Count of properties being read
        [in, size_is(cpspec * sizeof( PROPSPEC ))] 
        PROPSPEC const rgpspec[],           //Array of the properties to be read
        [in,out, size_is(cpspec * sizeof( PROPVARIANT )), length_is(cpspec)]
        PROPVARIANT rgvar[]                 //Array of PVARIANTs containing
                                            // the property values on return
    );

    HRESULT ReadPropertyNames(
        [in] ULONG cpropid,                 //Number of elements in rgpropid
        [in, length_is( cpropid ), size_is( cpropid * sizeof( PROPID ) )]
        PROPID const  rgpropid[],           //Property identifiers for
                                            // which names are to be retrieved
        [in,out, length_is( cpropid ), size_is( cpropid * sizeof( BSTR ) )]
        BSTR rglpwstrName[]                 //Array of returned string names
    );

    HRESULT Enum(
        [out] IEnumSTATPROPSTG **ppenum     //Pointer to output variable
                                            // that receives the IEnumPROPSPEC
                                            // interface pointer
    );

    HRESULT ReadDWORD(
        [in] PROPID id,            // property to be read
        [out] DWORD* pValue        // the property value on return
    );

    HRESULT ReadLONG(
        [in] PROPID id,            // property to be read
        [out] LONG* pValue         // the property value on return
    );

    HRESULT ReadBOOL(
        [in] PROPID id,            // property to be read
        [out] BOOL* pValue         // the property value on return
    );

    HRESULT ReadULONGLONG(
        [in] PROPID id,            // property to be read
        [out] ULONGLONG* pValue    // the property value on return
    );

    HRESULT ReadBSTR(
        [in] PROPID id,            // property to be read
        [out] BSTR* pValue         // the property value on return
    );
}

[
    object,
    uuid(fcea0205-66eb-4794-b38f-13852095c785),
    local,
    helpstring("IDiaStackFrame Interface"),
    pointer_default(unique)
]
interface IDiaStackFrame: IUnknown
{
    PROPERTY_RO( DWORD,     type,                       1,  "type" );
    PROPERTY_RO( ULONGLONG, base,                       2,  "Base of the stack frame" );
    PROPERTY_RO( DWORD,     size,                       3,  "size of frame in bytes" );
    PROPERTY_RO( ULONGLONG, returnAddress,              4,  "return address of the frame" );
    PROPERTY_RO( ULONGLONG, localsBase,                 5,  "base of locals" );
    PROPERTY_RO( DWORD,     lengthLocals,               6,  "cbLocals" );
    PROPERTY_RO( DWORD,     lengthParams,               7,  "cbParams" );
    PROPERTY_RO( DWORD,     lengthProlog,               8,  "cbProlog" );
    PROPERTY_RO( DWORD,     lengthSavedRegisters,       9,  "cbSavedRegs" );
    PROPERTY_RO( BOOL,      systemExceptionHandling,    10, "fHasSEH" );
    PROPERTY_RO( BOOL,      cplusplusExceptionHandling, 11, "fHasEH" );
    PROPERTY_RO( BOOL,      functionStart,              12, "funcStart" );
    PROPERTY_RO( BOOL,      allocatesBasePointer,       13, "fUsesBP" );
    PROPERTY_RO( DWORD,     maxStack,                   14,  "maxStack" );
}

[
    object,
    uuid(ec9d461d-ce74-4711-a020-7d8f9a1dd255),
    local,
    helpstring("IDiaEnumStackFrames Interface"),
    pointer_default(unique)
]
interface IDiaEnumStackFrames: IUnknown
{
    HRESULT Next(
        [in] ULONG celt,          
        [out] IDiaStackFrame ** rgelt,
        [out] ULONG * pceltFetched 
    );

    HRESULT Reset();
}

typedef struct {
    DWORD       ulOffStart;             // offset 1st byte of function code
    DWORD       cbProcSize;             // # bytes in function
    DWORD       cdwLocals;              // # bytes in locals/4
    WORD        cdwParams;              // # bytes in params/4
    WORD        cdwFlags;               // Following stuff ...

    /*
    WORD        cbProlog : 8;           // # bytes in prolog
    WORD        cbRegs   : 3;           // # regs saved
    WORD        fHasSEH  : 1;           // TRUE if SEH in func
    WORD        fUseBP   : 1;           // TRUE if EBP has been allocated
    WORD        reserved : 1;           // reserved for future use
    WORD        cbFrame  : 2;           // frame type
    */
} FPODATA;

[
    object,
    uuid(43dbf56f-7f7f-4a09-9c83-5bab344f1c12),
    local,
    helpstring("IDiaStackWalkHelper Interface"),
    pointer_default(unique)
]
interface IDiaStackWalkHelper: IUnknown
{
    PROPERTY_ARRAY_RW( ULONGLONG, DWORD, registerValue, 1, "Register value." );         
    HRESULT readMemory(                     // Read memory for DIA
         [in] enum MemoryTypeEnum type,
         [in] ULONGLONG va,
         [in] DWORD cbData,
         [out] DWORD *pcbData,
         [out, size_is(cbData),
         length_is(*pcbData)] BYTE data[]
         );
    HRESULT searchForReturnAddress(         // search return address for DIA, return E_NOTIMPL to use DIA default
        [in] IDiaFrameData* frame,
        [out] ULONGLONG* returnAddress
        );
    HRESULT searchForReturnAddressStart(    // search return address for DIA, return E_NOTIMPL to use DIA default
        [in] IDiaFrameData* frame,
        [in] ULONGLONG startAddress,
        [out] ULONGLONG* returnAddress
        );
    HRESULT frameForVA(                     // Get frame data for this address          
         [in] ULONGLONG va,
         [out] IDiaFrameData **ppFrame
         );
    HRESULT symbolForVA(                    // Get symbol at this address, must be a SymTagFunctionType!
         [in] ULONGLONG va,
         [out] IDiaSymbol **ppSymbol
         );
}

[
    object,
    uuid(14341190-eff2-46af-9290-14fa980277b0),
    local,
    helpstring("IDiaStackWalker Interface"),
    pointer_default(unique)
]
interface IDiaStackWalker: IUnknown
{
    HRESULT getEnumFrames(
        [in]  IDiaStackWalkHelper *pHelper,
        [out] IDiaEnumStackFrames **ppEnum
        );
}

